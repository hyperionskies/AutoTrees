import bpy
import random
from math import cos, sin, pi

#-- import bpy for Blender, random for coordinate assignments, and cos/sin/pi for trig functions

########################################
#---        Global Variables        ---#
########################################

#--- Data file

# mac directory path sample
path = '/Users/hyperionskies/Desktop/BlenderProject/matrix_file_nr.txt'
# windows directory path sample
# path = 'C:/Users/zc600012/Desktop/Cohort_Database/matrix_file_big.txt'


#--- Outputs

#--- Folder
# mac directory path sample
renderpath = '/Users/hyperionskies/Desktop/BlenderProject/'
# windows directory path sample
# renderpath = 'C:/Users/zc600012/Desktop/Cohort_Database/'

#--- Color key
# mac directory path sample
colorkey = '/Users/hyperionskies/Desktop/BlenderProject/colorkey.txt'
# windows directory path sample
# colorkey = 'C:/Users/zc600012/Desktop/Cohort_Database/cohortmats.txt'


#--- year change

yearjump = 25


#--- Keyframing

# NOTE: Script does not affect Blender's fps; default is 24.

# keyincr - still = number of keyframes for change between years
# num keyframes still (x, for k+x in loops)
still = 24 
# num keyframes between years
keyincr = 72


#--- Scaling

# Tree scaling
scale = (0.0254)*(16/28.3)*0.3
# Additional scaling for specific tree model
xmod = 12
#--- xmod used for radius value instead of separate x/y values
#--- z scale modifier (full precision: 0.310608)
zmod = 0.311


#--- Coordinates

# coordinates will be between -(maxcoord-1) and maxcoord
maxcoord = 50


#--- Camera/Text orbit

# camera orbit radius
cradius = 55.0
# text orbit radius
tradius = 25.0

# NOTE: to change speed of orbit, adjust numk and/or kf
# number of locations on camera orbit to keyframe (will be evenly distr)
numk = 60
# frequency of camera keyframing
kf = 12


#--- Background

# radius of circle floor
floorscale = 60
# RGB color for floor
floorcolor = (0.046,0.028,0.015)
# RGB color for sky
skycolor = (0.315,0.390,0.477)


#--- Model data

# tree append setup; change blendfile to path for Trees.blend if moved
# section and obj should not need to be changed unless dealing with a different .blend
# mac directory path sample
blendfile = '/Users/hyperionskies/Desktop/BlenderProject/Trees.blend'
# windows directory path sample
# blendfile = 'C:/Users/zc600012/Desktop/Cohort_Database/Trees.blend'
section = '\\Object\\'
obj = 'tree'

filepath  = blendfile + section + obj
directory = blendfile + section
filename  = obj




########################################
#---       Blender Misc Setup       ---#
########################################

# use with Blender default object initializer
# sets objects to be on 1st layer w/ layers property
mylayers = [False] * 20
mylayers[0] = True

########################################
#---  Name Generator For Renaming   ---#
########################################

#--- NAME GENERATOR
#--- namenum holds an integer, nextname() staples
#--- that integer to the end of string 'tree' to create
#--- a unique model name

#--- Reason for use: appended objects are not auto-selected like
#--- normal Blender objects, so names cannot be taken from new models.
#--- However, if there is no model named 'tree', the next model will be
#--- called 'tree' (for this .blend) and can be referenced as such, 
#--- to change its name to the next string generated by this function
#--- to ensure the next tree is also called 'tree'. 

namenum = 0

def nextname():
	newname1 = 'tree'
	global namenum 
	newname2 = str(namenum)
	namenum += 1
	return newname1+newname2

########################################
#---    Coordinate List Creation    ---#
########################################

# define coordinates class
# essentially a tuple 
class Coord(object):
	x = 0
	y = 0

#function to make and return coordinates w an input
def make_Coord(X,Y):
	coordset = Coord()
	coordset.x = X
	coordset.y = Y
	return coordset

# set up list of coords for grid; takes each number within range and shrinks it
# to fit roughly within 15-16 units (all models will fit in default camera radius)
coords = []
for i in range((-1*maxcoord+1),maxcoord):
	fl_i = i/3.25
	for j in range((-1*maxcoord+1),maxcoord):
		fl_j = j/3.25
		coords.append(make_Coord(fl_i,fl_j))




########################################
#---   CAMERA ROTATION FUNCTIONS    ---#
########################################

# findx and findy are exclusively used for text and camera orbit calculations;
# calulate triangle side lengths based off radius and current angle

def findx(r,x):
	ans = sin(x)
	ans = ans*r
	return ans

def findy(r,x):
	ans = cos(x)
	ans = ans*r
	return ans

# rotatecam keyframes the entire camera orbit from keyframe 0 to lframe, circling continuously
# lframe is intended to be the last frame of the entire animation

def rotatecam(lframe):
	deg = 0.0
	for n in range(0,int(lframe/kf)+1):
		x = findx(cradius,deg) 
		y = findy(cradius,deg)
		bpy.context.active_object.rotation_euler = (1.5708,0.0,pi-deg)
		bpy.context.active_object.location = (x,y,8.0)
		bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=n*kf)
		bpy.context.active_object.keyframe_insert(data_path="rotation_euler", index=-1, frame=n*kf)
		deg += 2*pi/numk

# rotatetext keyframes the entire text orbit from keyframe 0 to lframe, circling continuously
# lframe is intended to be the last frame of the entire animation

def rotatetext(lframe):
	deg = 0.6435
	for n in range(0,numk+1):
		x = findx(tradius,deg)
		y = findy(tradius,deg)
		bpy.context.active_object.rotation_euler = (1.5708,0.0,pi-deg+0.6435)
		bpy.context.active_object.location = (x,y,15.0)
		bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=n*kf)
		bpy.context.active_object.keyframe_insert(data_path="rotation_euler", index=-1, frame=n*kf)
		deg +=2*pi/numk

# yeartext generates 1 text object for each year, keyframing visibility and calling rotatetext
# on each object to keep it in orbit
# lframe is intended to be the last frame of the entire animation

# Reason for implementation choice: no convenient keyframing option for text object's contents.
# Alternative found involved a driver that would result in at least 4 million keyframes for 
# intended final animation; much slower than this solution. Better solutions may exist.

def yeartext(lframe):
	textnames = []
	for n in range(0,(hold['maxyear']+1),yearjump):
		bpy.ops.object.text_add()
		ob=bpy.context.object
		textnames.append(ob.name)
		ob.data.body = "Year " + str(n)
		rotatetext(lframe)
	for i in range(0,len(textnames)):
		#make active
		name = textnames[i]
		bpy.context.scene.objects.active = bpy.data.objects[name]
		n = i*keyincr
		ob=bpy.data.objects[name]
		#make visible 
		ob.hide_render = False
		#keyframe @ n*keyincr
		bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=n)
		#keyframe @ (n*keyincr + still)
		bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=(n+still))
		#make invisible
		bpy.data.objects[name].hide_render = True
		#keyframe @ (n+1)*keyincr
		bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=(n+still-keyincr))
		bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=(n+keyincr))

########################################
#---    Model Creation/Deletion     ---#
########################################

#--- MODEL CREATION

def make_model(mydict,r,h,y,c,t,k,coordlist):
	# if no models to be repurposed, make new model
	if(len(mydict['oof']) is 0):
		# get a coordinate for new model
		rand = random.randrange(0,(len(coordlist)))
		item = coordlist.pop(rand)
		# append model to file
		bpy.ops.wm.append(filepath=filepath, filename=filename, directory=directory)
		# select model; important for renaming/keyframing
		bpy.context.scene.objects.active = bpy.data.objects['tree']
		# fetch next unique name, rename model, and save to n for use
		bpy.context.object.name = nextname()
		n = bpy.context.object.name
		# place model properly and save name + location to dict
		bpy.data.objects[n].location = (item.x,item.y,0.0)
		mydict['year'][y][c][t] = {'name': n, 'loc': item}
		# scale very small to show "growth" into sapling if not year 0
		bpy.data.objects[n].scale = (0.001,0.001,0.001)
		# add base material and set color
		bpy.data.objects[n].data.materials.append(bpy.data.materials['base'])
		bpy.data.objects[n].color = get_color(mydict['year'][y][c]['species'])
		# set object active for keyframing
		bpy.context.scene.objects.active = bpy.data.objects[mydict['year'][y][c][t]['name']]
		# if year is not 0, keyframe location and scale so it starts very small, and call
		# make_invis and make_appear so that it becomes visible as it begins growing
		if k != 0:
			bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k-int((keyincr-still)/2))
			bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k-int((keyincr-still)/2))
			make_invis(n,k)
			make_appear(n,k)
		# set to appropriate scale
		bpy.data.objects[mydict['year'][y][c][t]['name']].scale = (r,r,0.0)
	# if models to be repurposed, use old model
	else:
		repurpose_model(mydict,y,c,t,r,h,k)
		bpy.data.objects[mydict['year'][y][c][t]['name']].scale = (r,r,0.0)
	# scale to appropriate size
	bpy.data.objects[mydict['year'][y][c][t]['name']].scale = (r,r,0.0)
	


# delete_model places model into list of models to be repurposed

# Reason for implementation choice: actual deletion removes models from animation entirely,
# minimizes total number of models required

def delete_model(mydict,y,c,t,k):
	# get name/coordinates
	name = mydict['year'][y][c][t]['name']
	loc = mydict['year'][y][c][t]['loc']
	model = [name,loc]
	# add name/coordinates set to out of frame list
	mydict['oof'].append(model)
	#set model to be invisible
	make_invis(name,k)
	bpy.data.objects[name].location = (loc.x,loc.y,0.0)
	# shrink down to create effect of "dying", make active, and keyframe
	bpy.data.objects[name].scale = (0.001,0.001,0.001)
	bpy.context.scene.objects.active = bpy.data.objects[name]
	bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k-int((keyincr-still)/2)-1)
	bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k-int((keyincr-still)/2)-1)


# update_model "grows" models that change in size between years

def update_model(mydict,r,h,y1,y2,c,t):
	name = mydict['year'][y1][c][t]['name']
	loc = mydict['year'][y1][c][t]['loc']
	#update name/loc in new year
	mydict['year'][y2][c][t] = {'name':name, 'loc':loc}
	#resize tree
	bpy.data.objects[name].scale = (r,r,h)


# repurpose_model takes a model from the out of frame list and changes its data to 
# that of a new tree

def repurpose_model(mydict,y,c,t,r,h,k):
	# get oof model from list, get name/location
	model = mydict['oof'].pop()
	name = model[0]
	item = model[1]
	# make model active
	bpy.context.scene.objects.active = bpy.data.objects[name]
	#add name/item to new tree data
	mydict['year'][y][c][t] = {'name': name, 'loc': item}
	#scale and keyframe
	bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k-int((keyincr-still)/2))
	bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k-int((keyincr-still)/2))
	bpy.data.objects[name].location = (item.x,item.y,0.0)
	bpy.data.objects[name].scale = (0.001,0.001,0.001)
	#set color and keyframe
	bpy.context.active_object.keyframe_insert(data_path="color", index=-1, frame=k-int((keyincr-still)/2))
	bpy.data.objects[name].color = get_color(mydict['year'][y][c]['species'])
	bpy.context.active_object.keyframe_insert(data_path="color", index=-1, frame=k-int((keyincr-still)/2)+1)
	# make "new" tree visible and keyframe
	make_appear(mydict['year'][y][c][t]['name'],k)
	bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k-int((keyincr-still)/2)+1)
	bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k-int((keyincr-still)/2)+1)


# make_invis and make_appear toggles visibility for rendering and keyframes
# keyframing is staggered to ensure if a tree goes invisible then visible in the same
# year transition, it is invisible for the time required to change its data

# primarily used by repurpose_model

def make_invis(name,k):
	bpy.context.scene.objects.active = bpy.data.objects[name]
	# set keyframe to beginning of animation phase (limits transition)
	bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=k-(keyincr-still)+1)
	# set model to be invisible
	bpy.data.objects[name].hide_render = True
	# keyframe visibility; set to (animation period length)/2
	bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=k-int((keyincr-still)/2))

def make_appear(name,k):
	bpy.context.scene.objects.active = bpy.data.objects[name]
	# set keyframe 
	bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=k-int((keyincr-still)/2))
	# set model to be visible
	bpy.data.objects[name].hide_render = False
	# keyframe visibility; set to (animation period length)/2+1, 
	bpy.context.active_object.keyframe_insert(data_path="hide_render", index=-1, frame=k-int((keyincr-still)/2)+1)

	


########################################
#---    Color List Creation    ---#
########################################

#--- List of colors pulled from for various species. 3 greyscale, 3 purple, 3 red, 3 blue,
#--- 	3 cyan, 3 green, 3 yellow, and 3 orange. 
#--- 24 total colors; for more than 24 species, more colors will need to be added
#--- NOTE: Blender RGB is a 0.0-1.0 scale, not 0-255. Divide standard RGB values by 255 when replacing colors.
#		   white		 grey				 black	       dark purple		   bright purple		mid purple			dark red 			bright red 			mid red 			dark blue 			bright blue 		mid blue 			dark cyan 			bright cyan 		mid cyan			dark green			bright green 		mid green			dark yellow 		bright yellow		mid yellow			dark orange			bright orange		mid orange
colors = [[1.0,1.0,1.0],[0.663,0.663,0.663],[0.0,0.0,0.0],[0.168,0.008,0.168],[0.665,0.0168,0.665],[0.701,0.235,0.701],[0.220,0.008,0.008],[0.855,0.044,0.044],[0.815,0.262,0.262],[0.023,0.010,0.209],[0.060,0.023,0.638],[0.235,0.175,0.723],[0.008,0.156,0.168],[0.022,0.624,0.672],[0.200,0.780,0.814],[0.008,0.168,0.010],[0.024,0.687,0.032],[0.188,0.672,0.672],[0.171,0.185,0.007],[0.701,0.761,0.017],[0.701,0.723,0.292],[0.168,0.080,0.007],[0.815,0.347,0.010],[0.651,0.381,0.093]]
# reverse colors so white is used first
colors.reverse()

# add_spec removes a color from "colors" and assigns it to a particular species,
# saving it into "cmap" for later reference

def add_spec(species,mydict):
	#make c the list of rgb values
	c = mydict['colors'].pop()
	#add species string to list
	c.insert(0,species)
	#append c to map of species to colors
	mydict['cmap'].append(c)


# get_color searches "cmap" for a given species string, then returns the color
# return is formatted for assigning object color specifically (R,G,B,1.0) not
# material colors, like diffuse or specular color, which are formatted (R,G,B)

def get_color(species):
	color = ()
	global hold
	for c in hold['cmap']:
		if c[0] == species:
			color = (c[1],c[2],c[3],1.0)
	return color

########################################
#--- FILE LINE READING FUNCTION  ---#
########################################

#--- USED TO TAKE STRING FROM readline() AND ADAPT INTO USABLE FORMAT
#--- takes string and dict of dicts; string is split and typecast into variables
#--- radius/height scaled using scale variable during assignment and halved
#--- radius halved from diameter info, height halved for blender purposes
#--- cohort list is checked for new cohort
#--- species list checked for new species/add_spec() called to add new material data
#--- check if year is in dict; if not add year
#--- add all data to cohortID in year
#--- check maxyear     * maxyear is used in several calculations for loops/last keyframe

#--- OF NOTE FOR read_line() FUNCTION
#--- file lines are in order of cohortID, year, species, trees, diameter, height
#--- dict[year][cohortID] = {species, trees, radius, height}
#--- specific tree information is added later on as trees are generated
 
def read_line(line,mydict):
	#split line and typecast/scale
	#file format is cohortID, year, species, trees, diameter, height
	s = line.split()
	cohortID = int(s[0])
	year = int(s[1])
	species = s[2]
	trees = int(s[3])
	radius = float(s[4])*scale*xmod/2
	height = float(s[5])*scale*zmod/2
	#check cohort list and potentially add
	if not cohortID in mydict['cohorts']:
		mydict['cohorts'].append(cohortID)
	#check species list and potentially add + assign color
	if not species in mydict['species']:
		mydict['species'].append(species)
		add_spec(species,mydict)
	#assign cohort to mydict
	if not year in mydict['year']:
		mydict['year'][year] = {}
	mydict['year'][year][cohortID] = {'species': species, 'trees': trees, 'radius': radius, 'height': height}
	# check if year is greater than last detected maxyear
	if year > mydict['maxyear']:
		mydict['maxyear'] = year


########################################
#--- Instantiate Containers   ---#
########################################

#--- hold is used to contain all necessary model information for easy function passing
hold = {'year':{0:{}},'loc':{},'cohorts':[],'species':[],'cmap':[],'colors':colors,'oof':[], 'maxyear':0}


####################################
#--- BEGINNING OF PROGRAM PROPER
#####################################

#--- Cleanup script; iterates through objects and removes any present
#--- Means any run of the script will be on a clean slate without any prior setup

for obj in bpy.data.objects:
    bpy.data.objects.remove(obj, do_unlink = True)


#--- Read from file and build dicts

db_file = open(path,'r')
test = db_file.readline().rstrip()
while not test is '':
	read_line(test,hold)
	test = db_file.readline().rstrip()


#--- Create 'base' material

bpy.data.materials.new(name = 'base')
bpy.data.materials['base'].diffuse_color = (1.0,1.0,1.0)
bpy.data.materials['base'].specular_color = (0.0,0.0,0.0)
bpy.data.materials['base'].use_object_color = True


#--- year 0 model creation / location assignment

# set k to use for keyframing; begins at 0
k = 0 

# iterate through cohorts in year 0
for c in hold['year'][0]:
	t = 0
	r = hold['year'][0][c]['radius']
	h = hold['year'][0][c]['height']
	# iterate through # trees in cohort, make each tree
	while t < hold['year'][0][c]['trees']:
		make_model(hold,r,h,0,c,t,k,coords)
		t+=1

# iterate through objects, keyframe for start and end of still period
for obj in bpy.data.objects:
	bpy.context.scene.objects.active = obj
	bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k)
	bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k)

for obj in bpy.data.objects:
	bpy.context.scene.objects.active = obj
	bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k+still)
	bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k+still)


#--- Years after 0

last = 0			# used to indicate previous year
y = last+yearjump	# used to indicate current year

# iterate over all years
while y <= hold['maxyear']:
	# increment keyframe first
	# ensures any deleted/created models are keyframed accurately in functions
	k+=keyincr

	# now = y for current year
	now = y
		
	#case of cohort vanishing between 0 and 25
	for c in hold['year'][last]:
		if c not in hold['year'][now]:
			t = 0 
			while t < hold['year'][last][c]['trees']:
				delete_model(hold,last,c,t,k)
				t+=1
	#case of cohort staying between 0 and 25
	for c in hold['year'][now]:
		if c in hold['year'][last]:
			r = hold['year'][now][c]['radius']
			h = hold['year'][now][c]['height']
			t = 0
			#case 1: same # trees
			if hold['year'][now][c]['trees'] == hold['year'][last][c]['trees']:
				while t < hold['year'][now][c]['trees']:
					update_model(hold,r,h,last,now,c,t)
					t+=1
			t = 0
			#case 2: fewer trees in new year
			if hold['year'][now][c]['trees'] < hold['year'][last][c]['trees']:
				#same as case 1 for trees in previous year
				while t < hold['year'][now][c]['trees']:
					update_model(hold,r,h,last,now,c,t)
					t+=1
				#remove remainder of trees in cohort
				while t < hold['year'][last][c]['trees']:
					delete_model(hold,last,c,t,k)
					t+=1
			t = 0	
			#case 3: more trees in new year
			if hold['year'][now][c]['trees'] > hold['year'][last][c]['trees']:
				#same as case 1 for trees in previous year
				while t < hold['year'][last][c]['trees']:
					update_model(hold,r,h,last,now,c,t)
					t+=1
				#continue for remainder of trees
				while t < hold['year'][now][c]['trees']:
					make_model(hold,r,h,now,c,t,k,coords)
					t+=1

	#case of cohort appearing between 0 and 25
	for c in hold['year'][now]:
		if c not in hold['year'][last]:
			r = hold['year'][now][c]['radius']
			h = hold['year'][now][c]['height']
			t = 0
			while t < hold['year'][now][c]['trees']:
				make_model(hold,r,h,now,c,t,k,coords)
				t+=1
		
	# last becomes current year, current year is incremented
	last = now
	y += yearjump
	
	# keyframe all objects for still period
	for obj in bpy.data.objects:
		if bpy.data.objects[obj.name].hide_render == False:
			bpy.context.scene.objects.active = obj
			bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k)
			bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k)

	for obj in bpy.data.objects:
		if bpy.data.objects[obj.name].hide_render == False:
			bpy.context.scene.objects.active = obj
			bpy.context.active_object.keyframe_insert(data_path="location", index=-1, frame=k+still)
			bpy.context.active_object.keyframe_insert(data_path="scale", index=-1, frame=k+still)


# calculate last keyframe for convenience
lastframe = k+keyincr

# set sky color
bpy.data.worlds['World'].horizon_color = skycolor

# create flat cylinder for floor, set to floor color and not shiny (specular is black)
bpy.ops.mesh.primitive_cylinder_add(location = (0.0,0.0,0.01), layers=mylayers)
bpy.data.objects['Cylinder'].scale = (60.0,60.0,0.0)
bpy.data.materials.new(name='brown')
bpy.data.materials['brown'].diffuse_color = floorcolor
bpy.data.materials['brown'].specular_color = (0.0,0.0,0.0)
bpy.data.objects['Cylinder'].data.materials.append(bpy.data.materials['brown'])

# add a camera, set to use when rendering, call rotatecam
bpy.ops.object.camera_add(location=(0.0,0.0,45.0), rotation=(0.0,0.0,1.5708), layers=mylayers)
bpy.context.scene.camera = bpy.context.object
rotatecam(lastframe)

# call yeartext to handle text creation and rotation
#yeartext(lastframe)


# add lighting from cardinal directions to ensure all models are brightly lit
bpy.ops.object.lamp_add(type='SUN',location=(75.0,0.0,30.0), rotation=(0.0,1.13446,0.0), layers=mylayers)
bpy.ops.object.lamp_add(type='SUN',location=(0.0,75.0,30.0), rotation=(0.0,1.13446,1.57079), layers=mylayers)
bpy.ops.object.lamp_add(type='SUN',location=(-75.0,0.0,30.0), rotation=(0.0,-1.13446,0.0), layers=mylayers)
bpy.ops.object.lamp_add(type='SUN',location=(0.0,-75.0,30.0), rotation=(0.0,1.13446,-1.57079), layers=mylayers)


# set render data
bpy.data.scenes['Scene'].frame_start = 0
bpy.data.scenes['Scene'].frame_end = lastframe
bpy.data.scenes['Scene'].render.filepath = renderpath
bpy.data.scenes['Scene'].render.image_settings.file_format =  'AVI_RAW'

# render
bpy.ops.render.render(animation=True)

s = '\t'
f = open(colorkey, 'w')
for l in hold['cmap']:
        j = s.join([l[0],str(round(l[1]*255,3)),str(round(l[2]*255,3)),str(round(l[3]*255,3))])
        f.write(j)
        f.write('\n')
f.close()
